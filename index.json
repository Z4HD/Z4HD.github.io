[{"categories":null,"content":" Every cycle, a tragedy. ","date":"2019-08-20","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["运维"],"content":"现象 使用 podman-compose up -d 启动容器后，容器在后台运行正常。但关闭SSH连接一段时间后（通常1h内）全部容器停止运行，退出代码（Exit Code）为0，代表容器被正常停止。 使用 podman-compose logs 查看日志，发现容器内的进程因接收到 SIGTERM 信号而正常停止。 由于 docker-compose.yaml 中已设置 restart: unless-stopped，容器只有被手动停止时不会自行重启，佐证了容器被正常停止的判断。 如果用户保持登录，则容器不会停止。 ","date":"2024-05-17","objectID":"/posts/2024-05-17-systemd-linering/:1:0","tags":["GNU/Linux"],"title":"防止后台运行的 podman 容器在当前用户退出SSH后离奇死亡","uri":"/posts/2024-05-17-systemd-linering/"},{"categories":["运维"],"content":"原因 true 发现容器死了，应排查发送 SIGTERM 信号的凶手。仅设置保活治标不治本。 根据“用户不退出，容器不停止”的特点进行搜索，发现幕后真凶是 systemd 于 v230 版本引入的一项更改导致。 v230 版本将 KillUserProcesses= 的默认值由 no 变更为 yes，使得默认情况下 systemd 会在用户完全退出登录时，杀死用户名下的所有进程。 查看关于此更改的描述（英文原文）：CHANGES WITH 230 由于使用 podman 运行的 rootless 容器在 systemd 中属于当前用户名下的进程，因此不幸躺枪。 ","date":"2024-05-17","objectID":"/posts/2024-05-17-systemd-linering/:2:0","tags":["GNU/Linux"],"title":"防止后台运行的 podman 容器在当前用户退出SSH后离奇死亡","uri":"/posts/2024-05-17-systemd-linering/"},{"categories":["运维"],"content":"解决方案 下列解决方案任选其一。 ","date":"2024-05-17","objectID":"/posts/2024-05-17-systemd-linering/:3:0","tags":["GNU/Linux"],"title":"防止后台运行的 podman 容器在当前用户退出SSH后离奇死亡","uri":"/posts/2024-05-17-systemd-linering/"},{"categories":["运维"],"content":"启用 Lingering loginctl enable-linger loginctl user-status\" loginctl user-status 检查当前用户是否启用 lingering？ loginctl user-status 如有 Linger: yes ，说明当前用户已启用 lingering。 其他方法参考：systemd - loginctl enable-linger/disable-linger … but reading linger-status? - Server Fault ","date":"2024-05-17","objectID":"/posts/2024-05-17-systemd-linering/:3:1","tags":["GNU/Linux"],"title":"防止后台运行的 podman 容器在当前用户退出SSH后离奇死亡","uri":"/posts/2024-05-17-systemd-linering/"},{"categories":["运维"],"content":"手动指定 systemd 的行为 编辑 /etc/systemd/logind.conf KillUserProcesses=no ","date":"2024-05-17","objectID":"/posts/2024-05-17-systemd-linering/:3:2","tags":["GNU/Linux"],"title":"防止后台运行的 podman 容器在当前用户退出SSH后离奇死亡","uri":"/posts/2024-05-17-systemd-linering/"},{"categories":["运维"],"content":"tmux 保活 不推荐此方法 保持一个当前用户的 tmux session 在后台，可以临时缓解该问题。 ","date":"2024-05-17","objectID":"/posts/2024-05-17-systemd-linering/:3:3","tags":["GNU/Linux"],"title":"防止后台运行的 podman 容器在当前用户退出SSH后离奇死亡","uri":"/posts/2024-05-17-systemd-linering/"},{"categories":["运维"],"content":"Reference Github Issue: rootless podman containers stop after logging out / disconnecting ssh session Systemd NEWS: CHANGES WITH 230 ","date":"2024-05-17","objectID":"/posts/2024-05-17-systemd-linering/:4:0","tags":["GNU/Linux"],"title":"防止后台运行的 podman 容器在当前用户退出SSH后离奇死亡","uri":"/posts/2024-05-17-systemd-linering/"},{"categories":["运维"],"content":"由于 Podman 默认网络 podman 未启用 IPv6，因此默认情况下，容器仅具备访问 IPv4 网络的能力。 通过本文所述的方法可以让容器内运行的程序具备访问 IPv6 网络的能力。 ","date":"2024-03-02","objectID":"/posts/2024-03-02-podman-container-access-ipv6/:0:0","tags":["GNU/Linux","Podman"],"title":"让 Podman 容器具备访问 IPv6 网络的能力","uri":"/posts/2024-03-02-podman-container-access-ipv6/"},{"categories":["运维"],"content":"0x00 系统需求 宿主机（host）具备有效的IPv6地址，能够正常访问 IPv6 网络。 Podman 4.0+ Podman 网络堆栈已切换为 netavark 1 如何检查 Podman 当前正在使用何种网络堆栈？ 执行 podman info | grep -i networkBackend 检查输出为 networkBackend: netavark，证明 Podman 当前正在使用的网络堆栈为 netavark 。 ","date":"2024-03-02","objectID":"/posts/2024-03-02-podman-container-access-ipv6/:1:0","tags":["GNU/Linux","Podman"],"title":"让 Podman 容器具备访问 IPv6 网络的能力","uri":"/posts/2024-03-02-podman-container-access-ipv6/"},{"categories":["运维"],"content":"0x01 创建 IPv6 双栈网络 创建一个名称为 podnetv6 的用户定义网络，名称可以自定义，此处仅作示例。 podman network create --ipv6 podnetv6 ","date":"2024-03-02","objectID":"/posts/2024-03-02-podman-container-access-ipv6/:2:0","tags":["GNU/Linux","Podman"],"title":"让 Podman 容器具备访问 IPv6 网络的能力","uri":"/posts/2024-03-02-podman-container-access-ipv6/"},{"categories":["运维"],"content":"0x02 将容器接入 IPv6 双栈网络 将网络连接至正在运行的容器。 podman network connect podnetv6 \u003cCONTAINER NAME\u003e podman restart \u003cCONTAINER NAME\u003e 对于新运行的容器，可以直接使用 0x01 步中创建的 IPv6 双栈网络，而非默认的 IPv4 单栈网络 podamn 。 podman run --network podnetv6 注意 如需通过 IPv6 地址访问容器，建议在执行 podman network connect 或 podman run 时添加 --ip6 为容器分配静态IPv6地址。 分配的静态地址应当位于所连接的网络的网段内。不知道虚拟网络的网段信息？请执行 podman network inspect \u003cNETWORK NAME\u003e ","date":"2024-03-02","objectID":"/posts/2024-03-02-podman-container-access-ipv6/:3:0","tags":["GNU/Linux","Podman"],"title":"让 Podman 容器具备访问 IPv6 网络的能力","uri":"/posts/2024-03-02-podman-container-access-ipv6/"},{"categories":["运维"],"content":"Reference Podman 4.0’s new network stack: What you need to know How to configure Podman 4.0 for IPv6 - Red Hat Developer Configuring Networking for Podman - Orcale Linux Podman User’s Guide 将网络堆栈从 CNI 切换到 Netavark - Red Hat Customer Portal ↩︎ ","date":"2024-03-02","objectID":"/posts/2024-03-02-podman-container-access-ipv6/:4:0","tags":["GNU/Linux","Podman"],"title":"让 Podman 容器具备访问 IPv6 网络的能力","uri":"/posts/2024-03-02-podman-container-access-ipv6/"},{"categories":["手机"],"content":"老手机服役7年，出现充电时 Type-C 尾插接触不良，拔出时阻尼很小的现象。经过搜索发现，可能是尾插内积灰过多，插头插不到底部导致的。因此将手机关机后使用一根缝衣针，将 Type-C 尾插底部的种种污秽勾出，尾插瞬间满血复活，插拔手感也得到了极大的改善。 ","date":"2024-02-20","objectID":"/posts/2024-02-20-cleanup-typec-solt/:0:0","tags":[],"title":"清洁手机的 Type-C 尾插","uri":"/posts/2024-02-20-cleanup-typec-solt/"},{"categories":["实用软件"],"content":"在一些需要提供xx证正反面复印件的场合，而自己手上只有手机里刚刚拍摄的正反面照片。如果打印全页照片，费墨且不美观，甚至不符合要求。此时便可使用万能的 Ps 或 GIMP 来处理。 新建文件，模板选A4（或者你需要打印的纸张大小），分辨率 300ppi / 600ppi（或根据打印机确定） 不要再修改当前文档的分辨率。 将要打印的图像粘贴到当前文档。 使用缩放工具，单位由 px 更改为 mm / cm，尺寸填写现实中测量/查询得到的尺寸。 移动到它在纸上应当出现的位置。或者“垂直居中+水平居中”。 上述方法对于任何需要控制打印内容在物理世界中尺寸的场景均适用。 下图中的数据以xx证的尺寸为例。 GIPM 缩放设置样例\" GIPM 缩放设置样例 ","date":"2024-02-20","objectID":"/posts/2024-02-20-sfz-scale/:0:0","tags":["GIMP"],"title":"将普通的证件照片变为适合打印的A4纸扫描件","uri":"/posts/2024-02-20-sfz-scale/"},{"categories":["实用软件"],"content":"0x00 基本参数 INFO 按照实际情况修改 \u003cVAR\u003e 中的内容。 lftp -p \u003c端口\u003e -u \u003c用户名\u003e sftp://\u003c服务器地址/域名\u003e ","date":"2023-10-15","objectID":"/posts/2023-10-15-use-lftp-replace-sftp/:1:0","tags":["GNU/Linux"],"title":"使用 lftp 替代 sftp","uri":"/posts/2023-10-15-use-lftp-replace-sftp/"},{"categories":["实用软件"],"content":"0x01 使用私钥登录 如何使用私钥登陆 ssh 服务器此处不再赘述，详见各类 ssh 教程。 建议先使用 sftp 尝试登陆，以排除 ssh 本身的配置问题。 指定一个不在默认位置的私钥 根据 lftp 的 man 手册，需要在配置文件中修改 sftp:connect-program 来手动指定私钥的位置。 set sftp:connect-program \"ssh -a -x -i \u003c私钥的绝对路径路径\u003e\" 建议将上述代码添加到 ~/.lftprc 中。 还可以使用使用 ssh-agent + ssh-add 达到相同的目的。 ","date":"2023-10-15","objectID":"/posts/2023-10-15-use-lftp-replace-sftp/:2:0","tags":["GNU/Linux"],"title":"使用 lftp 替代 sftp","uri":"/posts/2023-10-15-use-lftp-replace-sftp/"},{"categories":["实用软件"],"content":"0x02 使用带密码的私钥登录 lftp -u \u003c用户名\u003e,\u003c私钥密码\u003e sftp://\u003c服务器地址\u003e ","date":"2023-10-15","objectID":"/posts/2023-10-15-use-lftp-replace-sftp/:3:0","tags":["GNU/Linux"],"title":"使用 lftp 替代 sftp","uri":"/posts/2023-10-15-use-lftp-replace-sftp/"},{"categories":["实用软件"],"content":"0x03 使用无密码的私钥登录 lftp -u \u003c用户名\u003e, sftp://\u003c服务器地址\u003e 其中 -u 参数用户名后的逗号是必须的。作用为指定一个空密码，以避免 lftp 在每次运行时询问密码。 ","date":"2023-10-15","objectID":"/posts/2023-10-15-use-lftp-replace-sftp/:4:0","tags":["GNU/Linux"],"title":"使用 lftp 替代 sftp","uri":"/posts/2023-10-15-use-lftp-replace-sftp/"},{"categories":["实用软件"],"content":"一种奇怪的需求：使用颜色反相将黑色背景的图片转换为白色背景图片的同时保持原有的色彩。 黑色背景的图片如果直接打印出来，会非常费墨。只应用颜色反相，虽然黑底变成白底了，但蓝色也变成黄色了，鬼火也变成蓝火了。本文探讨了一种方法，能够在应用颜色反相后保持除灰度外其余颜色不变。 以 GIMP 为例，对待处理的图片依次执行下列命令： 颜色 -\u003e 色相-浓度，将“色相（Range of affected hues）”设置为 -180 颜色 -\u003e 反相 此时图片应为白底黑字，但除黑白灰外的其他颜色仍维持原色。 \u003c-原图 | 效果图-\u003e\" \u003c-原图 | 效果图-\u003e 如果需要对多张图片进行上述处理，推荐使用BIMP插件，该插件为GIMP添加了批处理功能，与 Photoshop 中基于录制动作的批处理不同，BIMP需要用户在执行前手动编排动作指令及参数（指令序列可以导入导出）。 中文版GIMP找对应指令名称可能需要参考对应的英文文档。下表内容仅供参考。 中文名称 指令名 色相-浓度 gimp-drawable-hue-saturation 反向 gimp-drawable-invert ","date":"2023-06-03","objectID":"/posts/2023-06-03-pic-inverse-keep-colour/:0:0","tags":["GNU/Linux","GIMP"],"title":"图片颜色反相时保持色彩","uri":"/posts/2023-06-03-pic-inverse-keep-colour/"},{"categories":["代码"],"content":"使用展开语法合并对象，实现优雅的为对象属性赋默认值。 ","date":"2023-04-18","objectID":"/posts/2023-04-18-js-spread-init-object/:0:0","tags":["JavaScript"],"title":"使用ES2018中的展开语法为对象设置默认值","uri":"/posts/2023-04-18-js-spread-init-object/"},{"categories":["代码"],"content":"引言 思考下面这个函数，它接受一个对象，并取出其中的属性做一些操作。 function dataProcessor(data){ console.log(data.a); console.log(data.b); console.log(data.c); } dataProcessor({a:1,b:2,c:3}); /* \u003e \"1\" \u003e \"2\" \u003e \"3\" */ 如果传入的对象没有包含所有的属性，那么没有赋值的属性会输出 undefined。 dataProcessor({a:1}); /* \u003e \"1\" \u003e undefined \u003e undefined */ 比较经典的思维是使用 if 判断是否存在属性，但如果对象存在很多的成员，一个一个去判断不现实，而且大量的 if 会使得代码难以维护。 function dataProcessor(data){ // 默认值 if(!data.a) data.a=0; if(!data.b) data.b=0; if(!data.c) data.c=0; // 处理 console.log(data.a); console.log(data.b); console.log(data.c); } ","date":"2023-04-18","objectID":"/posts/2023-04-18-js-spread-init-object/:1:0","tags":["JavaScript"],"title":"使用ES2018中的展开语法为对象设置默认值","uri":"/posts/2023-04-18-js-spread-init-object/"},{"categories":["代码"],"content":"使用展开语法合并对象 下面的代码定义一个模板对象，其中包含所有的属性及其默认值，然后使用展开语法构建对象字面量，用 data 中的属性值覆盖模板 template 中的同名属性。 function dataProcessor(data){ // 默认值 const template = {a:0,b:0,c:0}; data = {...template, ...data}; // 处理 console.log(data.a); console.log(data.b); console.log(data.c); } dataProcessor({a:1}); /* \u003e 1 \u003e 0 \u003e 0 */ 上述方法具备语法简洁、易于维护且能够在不修改已有函数调用的前提下增加对象属性的优点。但仍具备一定的局限性： 如果需要在对象的某个属性不存在时执行赋默认值之外的操作，仍需在展开前使用 if 判断。 如果需要删除某个属性，仍然建议对代码库进行清理以避免非预期的行为。 也可以将其封装为函数。 function setDefault(data){ const template = {a:0,b:0,c:0}; return {...template, ...data}; } ","date":"2023-04-18","objectID":"/posts/2023-04-18-js-spread-init-object/:2:0","tags":["JavaScript"],"title":"使用ES2018中的展开语法为对象设置默认值","uri":"/posts/2023-04-18-js-spread-init-object/"},{"categories":["代码"],"content":"Reference 展开语法 - MDN Svelte Quick Tip: Creating a toast notification system - DEV Community ","date":"2023-04-18","objectID":"/posts/2023-04-18-js-spread-init-object/:3:0","tags":["JavaScript"],"title":"使用ES2018中的展开语法为对象设置默认值","uri":"/posts/2023-04-18-js-spread-init-object/"},{"categories":["运维"],"content":"记一次 Stable Update1 后由于内核版本较低不支持 zstd 导致的内核错误（Kernel Panic）。 ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:0:0","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"0x00 现象 sudo pamac update \u0026\u0026 reboot 内核恐慌 （蹬蹬咚）\" 内核恐慌 （蹬蹬咚） ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:1:0","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"0x01 原因分析 关键错误信息如下： [+] Initramfs unpacking failed: invalid magic at start of compressed archive [-] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) VFS: unable to mount root fs on unknown-block(0 0) 意味着内核无法挂载根文件系统。2 考虑到在本例中根文件系统使用了经典的 ext4 文件系统，因此问题不太可能由于内核不支持所用文件系统导致。考虑到当 grub 中 root= 参数错误时可能会导致此问题，通过 chroot 后重新安装 grub 尝试解决失败，因此排除 grub 的问题。 继续从另一条错误信息 Initramfs unpacking failed: invalid magic at start of compressed archive 入手，通过很多很好的检索3，最终确认原因如下： [Stable Update] 2023-03-311 引入了一个 mkinitcpio 更新 （34-1.1 -\u003e 35.2-1），此更新将 initramfs 的默认压缩方式由 gzip 修改为 zstd4 目前正在使用的 Linux Kernel 5.4 不支持 zstd，需要 5.10+ 最终导致 mkinitcpio 生成的 initramfs 无法被内核读取。（Initramfs unpacking failed） ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:2:0","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"0x02 解决方案 使用 Linux Kernel 5.10+ 引导 chroot 后修改 COMPRESSION=\"gzip\" ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:3:0","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"开机 使用 Live CD 引导开机后 chroot 到当前 Manjaor Linux 安装5，此过程可通过 manjaro-chroot 自动完成。 sudo manjaro-chroot -a 由于在 Live CD 环境中使用 mhwd-kernel -i 安装内核失败，因此先修改 initramfs 压缩方式为 gzip，待进入系统后再更新内核。 vim /etc/mkinitcpio.conf 删除 #COMPRESSION=\"gzip\" 开头的 # (取消注释) ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:3:1","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"更新内核 选择 Manjaro Linux 中 5.x 内核最新的LTS版本 5.15 sudo mhwd-kernel -i linux515 更改 /etc/mkinitcpio.conf 中 COMPRESSION=\"zstd\"（可选） 卸载旧内核（可选） sudo mhwd-kernel -r linux54 ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:3:2","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"2023-04-02 更新 目前 Manjaro Linux 官方已发布 mkinitcpio 35.2-2，其默认压缩方式已改回 gzip。5.4 内核的用户现已能够安全升级而不会内核恐慌。 ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:4:0","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"0x03 感想 一个不滚包的用户，有两种可能性。一种是没有能力滚包。因为买不起高配的电脑和没有经常 pacman -Syu 等各种自身因素，他的人生都是失败的。第二种可能：有能力却不滚包的人，在有能力而没有滚包的想法时，那么这个人的思想境界便低到了一个令人发指的程度。一个有能力的人不付出行动来证明自己，只能证明此人技术素质修养之低下。是灰暗的，是不被真正的技术社区认可的，理解不了这种滚动的时刻保持最新的高雅包管理方式，他只能看到外表的版本堆砌，参不透其中深奥的 Kernel Panic，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。 ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:5:0","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["运维"],"content":"Reference [Stable Update] 2023-03-31 - Kernels, Plasma 5.27 LTS, Pamac, Phosh, Mesa, LibreOffice ↩︎ not syncing: VFS: Unable to mount root fs on unknown-block(0,0) - StackExchange ↩︎ Initramfs unpacking failed: invalid magic as start of compressed - Support - Manjaro Linux Forum ↩︎ Switch to zstd by default (2f4a2b59) · Commits · Arch Linux / Mkinitcpio / mkinitcpio · GitLab ↩︎ GRUB/Restore the GRUB Bootloader - Manjaro Wiki ↩︎ ","date":"2023-04-01","objectID":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/:6:0","tags":["GNU/Linux"],"title":"处理 Manjaro Linux 升级后内核错误","uri":"/posts/2023-04-01-my-first-kernel-panic-in-manjaro/"},{"categories":["代码","实用软件"],"content":"使用 Visual Studio Code 通过 SSH 连接远端服务器中使用 Podman 创建的 Dev Container。 具备如下优势： 本地除了 Visual Studio Code （含插件）和 SSH 之外无需安装任何开发依赖，避免污染本地环境。 除 vscode-server 之外一切开发依赖均位于容器之中，避免污染远端环境。 多谢 Podman 之 rootless 特性，服务器无需维持一个 root 权限的 Docker Deamon 长期运行，减少了可能的攻击面。 可将开发环境部署工作写入 Dockerfile 和 快速重建 Dev Container 劣势： 远端服务器和 Dev Container 中均会被安装 .vscode-server。 容器会常驻后台除非手动停止。 ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:0:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"名词解释 此处约定一些名词概念，作用域仅限本文。 本地（Local OS）：一台可以运行 Visual Studio Code，用于敲代码的电脑，比如你正在用的主力机。 远端（Remote OS）：一台可以通过SSH连接的远程服务器，用于开发环境，可能是NAS/VPS/老旧电脑… 开发容器（Dev Container）：用于安装开发环境的容器。感觉“开发容器”这词有点动词的味道，这里认为它是名词。 VSC：Visual Studio Code INFO vscode-server != Visual Studio Code for the Web ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:1:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"基本架构概述 千言万语不如一张图。 ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:2:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"0x00 准备工作 ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:3:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"本地准备 安装VSC 安装SSH，用于登录远端服务器的SSH密钥对不建议设置密码，防止VSC因为密码卡住。 安装VSC插件：Visual Studio Code Remote Development Extension Pack 此插件文档很详细，推荐阅读。 不用WSL的可以选择卸载WSL插件或者手动安装 Remote - SSH 和 Dev Containers ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:3:1","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"远端准备 配置SSH 安装 Podman (或者用之前装好的) 足够的磁盘空间（个人建议20G+） ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:3:2","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"0x01 连接远端SSH 阅读：Remote Development using SSH 完成上面的文档，我们已经有了一个SSH远程开发环境，此时可以在远端服务器中下载/克隆你的项目文件。 阅读：Alternate ways to install Docker - Podman 根据上面的教程（英文）编辑插件设置，将Containers: Docker Path的值替换为 podman。完成后检查远程资源管理器 -\u003e Dev Container，如能看到正在运行的 Podman 容器，则配置成功。 ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:4:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"0x02 创建 devcontainer.json TIP 本步建议在项目文件夹中进行。 推荐阅读：Create a Dev Container 别被文档里密密麻麻的JSON吓到，创建 devcontainer.json 的最好办法是按F1选 Dev Containers: Add Dev Container Configuration Files… Podman 作为一种别样的 rootless 容器工具，需要在 devcontainer.json 中附加额外的配置： \"runArgs\": [ \"--userns=keep-id\" ], \"containerEnv\": { \"HOME\": \"/home/node\" } 上述设置可以避免VSC自动在开发容器中安装 vscode-server 时遇到 mkdir: cannot create directory '/root': Permission denied 不要忘了添加自己喜欢的VSC插件。此处指定的插件会在容器内安装 code server 时自动安装。 \"customizations\": { \"vscode\": { \"extensions\": [ \"Gruntfuggly.todo-tree\", \"mhutchie.git-graph\" ] } } ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:5:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"0x03 构建开发容器镜像 TIP 容器构建尤其是首次构建必须在 Remote SSH 状态下进行 开发容器镜像应根据你所用开发环境的实际需求进行构建，此处以使用恶臭 Node.js 的 Svelte Kit 前端项目为例。 根据实际开发环境需求编辑 Dockerfile，此处以一个典型的 Node.js 开发环境为例。包含最新版 npm 和 cnmp。 FROMnode:18# Install basic development toolsRUN apt update \u0026\u0026 apt install -y less man-db sudo# Ensure default `node` user has access to `sudo`ARG USERNAME=node RUN echo $USERNAME ALL=\\(root\\) NOPASSWD:ALL \u003e /etc/sudoers.d/$USERNAME \\ \u0026\u0026 chmod 0440 /etc/sudoers.d/$USERNAME# Set `DEVCONTAINER` environment variable to help with orientationENV DEVCONTAINER=true # Install cnpm (mainland network only)RUN npm -g config set registry=https://registry.npmmirror.com \\ \u0026\u0026 npm install npm@latest -g \\ \u0026\u0026 npm install cnpm -g","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:6:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"0x04 进入开发容器 F1 –\u003e Dev Containers: Reopen in Container ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:7:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["代码","实用软件"],"content":"参考文献 Replacing Docker with Podman for your VSCode DevContainers 点评：此文主要介绍在 Windows 下连接本地WSL中运行的 Podman 的步骤 Develop on a remote Docker host - Connect using the Remote - SSH extension 点评：此VSC文档提供了推荐的连接远程 docker host 中 Dev Containers 的步骤 Developing inside a Container 点评：此VSC文档详细的介绍了 Dev Containers 的种种特性，很长，很详细。 ","date":"2023-01-18","objectID":"/posts/2023-01-18-vsc-rd-in-podman/:8:0","tags":["GNU/Linux","Visual Studio Code","Podman"],"title":"Visual Studio Code 连接远程 Podman Dev Container","uri":"/posts/2023-01-18-vsc-rd-in-podman/"},{"categories":["手机"],"content":"本文探讨一种备份 Internal Storage (内置存储)1 的方法，具备下列特性： 直接将备份文件传输至PC，不产生额外的中间文件。 支持 gzip/bzip2/xz 等压缩方式2 备份文件作为tar包，可以浏览文件列表或提取其中的部分文件。以及其他 tar archive 特性。 使用管道（pipe）直接将 tar 包释放到内置存储，不产生额外的中间文件。 危险 不当操作可能对您的设备和数据造成不可逆的损害。 在执行任何ADB指令前务必进行细致的检查，确保已经理解将要进行的操作。 平台支持 平台支持：GNU/Linux，Windows (with git-bash) 详见：已知问题 ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:0:0","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"exec-out 与 exec-in ADB有两个不包含在 help 中的命令：exec-out 和 exec-in。作用分别为向标准输出输出“不加料”的内容；和从标准输入读取内容，做为 command 的标准输入。 网上相关资料比较少，列出一些链接供参考。 Add “exec” service: shell commands with no pty. - Google Git Read binary stdout data like screencap data from adb shell? - StackOverflow Transferring binary data over ADB shell - StackOverflow ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:1:0","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"备份 ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:2:0","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"GNU/Linux or Git Bash on Windows 将 /sdcard 打包并在PC端用 gzip 压缩，压缩等级5。不包含 /sdcard/Android/ adb exec-out \"cd /sdcard; tar -c --exclude Android/ -f - .\" | gzip -5 \u003e PATH_TO_BACKUP_FILE.tar.gz cd /sdcard; Internal Storage路径，不同手机可能有区别。此项也用来指定 tar 包中的根目录。 --exclude Android/ 排除某个特定的目录，该选项可以根据实际情况修改并重复添加。详情参考 man tar。 -f - 输出至标准输出。一般不用修改。 . 指定要包含在 tar 包中的目录，修改此项可以单独打包指定的文件夹。 ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:2:1","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"Windows CMD 无压缩 将 /sdcard 打包，无压缩。不包含 /sdcard/Android/ adb exec-out \"cd /sdcard; tar -c --exclude Android/ -f - .\" \u003e PATH_TO_BACKUP_FILE.tar ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:2:2","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"Windows CMD + 7z.exe 将 /sdcard 打包并在PC端用 7z 压缩，默认压缩等级。不包含 /sdcard/Android/ adb exec-out \"cd /sdcard; tar -c --exclude Android/ -f - .\" | 7z a -si PATH_TO_BACKUP_FILE.tar.7z 可以在终端中看到7z输出当前已处理的数据量，四舍五入就是一个进度条。 ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:2:3","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"还原 此处示例针对 tar.7z，tar.gz 使用标准 tar 命令即可处理，此处不再赘述。 ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:3:0","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"本地测试 7z x -so PATH_TO_BACKUP_FILE.tar.7z | tar tvf - ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:3:1","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"真机还原测试 7z x -so PATH_TO_BACKUP_FILE.tar.7z | adb exec-in \"tar tvf - \u003e /sdcard/test.log\" adb shell \"cat /sdcard/test.log\" ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:3:2","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"解压 tar 包至 Internal Storage 警告 下列指令未经测试 7z x -so PATH_TO_BACKUP_FILE.tar.7z | adb exec-in \"tar xf - -C /sdcard/ 2\u003e/sdcard/extract.log\" ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:3:3","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"已知问题 ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:4:0","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"手机端 tar 压缩后文件在PC端得到 Unexpected EOF CMD/git-bash 产生的 tar 文件 （使用 tar tvf 验证，下同） gzip: stdin: unexpected end of file tar: Unexpected EOF in archive tar: Error is not recoverable: exiting now 解决方案：移动端使用 tar -c 创建无压缩的 tar 文件，在PC端进行压缩。由于此操作用到管道(pipe)，而且要求压缩软件支持从标准输入读取，在 Windows 平台可能需要搭配 git-bash 或 WSL使用。或者使用CMD时仅保存无压缩的文件。 我不太会用CMD的pipe特性，而且只知道有7z.exe能够从标准输入读取，此处留给读者自行尝试将前文的命令改写为CMD兼容。 ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:4:1","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"PowerShell 使用 \u003e 无法得到正确的 tar 文件 PowerShell 产生的 tar 文件 gzip: stdin: not in gzip format tar: Child returned status 1 tar: Error is not recoverable: exiting now 临时解决方案：不用 PowerShell ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:4:2","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"参考文献 How to backup compressed data from your android device to your computer What is a data/media device? - TeamWin ↩︎ Gzip vs Bzip2 vs XZ Performance Comparison - RootUsers ↩︎ ","date":"2022-12-22","objectID":"/posts/2022-12-22-backup-internal-storage-using-tar/:5:0","tags":["ADB"],"title":"打包备份 Android 手机的 Internal Storage 至 PC","uri":"/posts/2022-12-22-backup-internal-storage-using-tar/"},{"categories":["手机"],"content":"将文件从 Android 手机传输到PC的两种常用方式如下： MTP adb pull 本文将从实际传输速度的角度，对上述两种传输方式进行对比。 INFO 由于本文不是一篇严谨的研究，故存在下列局限性： 本文暂不涉及使用 adb exec-out 通过管道（pipe）传输数据的方式。 本文不探讨理论分析的内容。 本文只涉及 Windows 平台下的 MTP 实现。不探讨其他平台下的 MTP 实现。 由于作者时间有限，没有将测试重复三次以上，测试结果可能受到某些偶然因素的影响。 ","date":"2022-12-22","objectID":"/posts/2022-12-22-adb-pull-vs-mtp/:0:0","tags":["ADB"],"title":"ADB PULL vs MTP","uri":"/posts/2022-12-22-adb-pull-vs-mtp/"},{"categories":["手机"],"content":"准备工作 测试平台 Phone: OnePlus 5T USB 2.0，理论传输速度 480 Mbps = 60 MB/s Android 12, DerpFest ROM PC: Windows 10 兼容机 ADB: Android Debug Bridge version 1.0.41 Version 33.0.3-8952118 测试过程中，将手机通过原装数据线直接连接到电脑后面板的USB3.0接口上，以减少可能出现的线路损耗。 在手机的 Internal Storage 中创建一个大小为 1GB 的空文件。稍后会将这个文件在手机和电脑之间来回拷贝并计量消耗的时间。 dd if=/dev/zero of=/sdcard/test.1gb bs=1M count=1024 此时可以顺便测试出手机的顺序写性能为 300 MB/s 左右。 关于 /sdcard /sdcard/ 应该是一个指向 Internal Storage 的链接，但并不是所有手机都有这个链接。关于 Internal Storage 的更多信息可以参考下面的文章。 What is a data/media device? - TeamWin ","date":"2022-12-22","objectID":"/posts/2022-12-22-adb-pull-vs-mtp/:1:0","tags":["ADB"],"title":"ADB PULL vs MTP","uri":"/posts/2022-12-22-adb-pull-vs-mtp/"},{"categories":["手机"],"content":"MTP 在文件资源管理器中，对测试文件执行无情拖拽。手动计时。 结果 方式 时间 速度 Phone -\u003e PC 34.56s 29.63 MB/s PC -\u003e Phone 28.16s 36.36 MB/s ","date":"2022-12-22","objectID":"/posts/2022-12-22-adb-pull-vs-mtp/:2:0","tags":["ADB"],"title":"ADB PULL vs MTP","uri":"/posts/2022-12-22-adb-pull-vs-mtp/"},{"categories":["手机"],"content":"ADB PULL 使用ADB拉取文件到PC的当前目录下。 adb pull /sdcard/test.1gb . 结果 /sdcard/test.1gb: 1 file pulled, 0 skipped. 33.4 MB/s (1073741824 bytes in 30.674s) 将当前目录中 test.1gb 推送至手机 Internal Storage 的根目录。 由于压缩使测速结果失真 test.1gb: 1 file pushed, 0 skipped. 950.3 MB/s (1073741824 bytes in 1.078s) push指令瞬间完成，可能是由于压缩导致的，使用 -Z 参数关闭压缩。更多参数详见 adb --help，此处不做展开。 通过本次测试还可以发现，对于 adb pull，压缩默认关闭；对于 adb push，压缩默认启用。 adb push -Z test.1gb /sdcard/ 结果 test.1gb: 1 file pushed, 0 skipped. 28.9 MB/s (1073741824 bytes in 35.494s) ","date":"2022-12-22","objectID":"/posts/2022-12-22-adb-pull-vs-mtp/:3:0","tags":["ADB"],"title":"ADB PULL vs MTP","uri":"/posts/2022-12-22-adb-pull-vs-mtp/"},{"categories":["手机"],"content":"测速结果对比 方式 MTP ADB PULL Phone -\u003e PC 29.63 MB/s 33.4 MB/s PC -\u003e Phone 36.36 MB/s 28.9 MB/s ","date":"2022-12-22","objectID":"/posts/2022-12-22-adb-pull-vs-mtp/:4:0","tags":["ADB"],"title":"ADB PULL vs MTP","uri":"/posts/2022-12-22-adb-pull-vs-mtp/"},{"categories":["手机"],"content":"总结 通过上表可以发现，MTP和ADB之间的速度并没有本质上的区别。而且他们都比 USB 2.0 的理论速度慢了约50%。不过如果考虑到MTP的固有问题（例如：手机上刚下载好的文件电脑上看不到；查看含有大量文件的文件夹时缓慢的加载速度），以及表中微小的速度差异，从手机向电脑拷贝文件的最佳方案是使用 adb pull，从电脑向手机拷贝文件的最佳方案是使用MTP。 ","date":"2022-12-22","objectID":"/posts/2022-12-22-adb-pull-vs-mtp/:5:0","tags":["ADB"],"title":"ADB PULL vs MTP","uri":"/posts/2022-12-22-adb-pull-vs-mtp/"},{"categories":["运维","故障排除"],"content":"症状 无法正常设置WiFi Country Code，也无法通过 iw reg get 查看到正确的 Country Code 信息。 ","date":"2022-10-16","objectID":"/posts/2022-10-16-change-wifi-country-code-in-f34/:1:0","tags":["GNU/Linux","Fedora"],"title":"Fedora 34 中无法修改无线网卡的 county code","uri":"/posts/2022-10-16-change-wifi-country-code-in-f34/"},{"categories":["运维","故障排除"],"content":"问题原因 f34的软件源中的 crda 已被 wireless-regdb 取代。 ","date":"2022-10-16","objectID":"/posts/2022-10-16-change-wifi-country-code-in-f34/:2:0","tags":["GNU/Linux","Fedora"],"title":"Fedora 34 中无法修改无线网卡的 county code","uri":"/posts/2022-10-16-change-wifi-country-code-in-f34/"},{"categories":["运维","故障排除"],"content":"解决方案 sudo dnf install wireless-regdb 安装完成后重启，使用 iw reg get 查看到的区域信息应恢复正常。 $ iw reg get global country US: DFS-FCC (2402 - 2472 @ 40), (N/A, 30), (N/A) (5170 - 5250 @ 80), (N/A, 30), (N/A), AUTO-BW (5250 - 5330 @ 80), (N/A, 24), (0 ms), DFS, AUTO-BW (5490 - 5730 @ 160), (N/A, 24), (0 ms), DFS (5735 - 5835 @ 80), (N/A, 30), (N/A) (57240 - 70200 @ 2160), (N/A, 40), (N/A) 后续便可以通过 sudo iw reg set 设置无线网卡的 Country Code。 ","date":"2022-10-16","objectID":"/posts/2022-10-16-change-wifi-country-code-in-f34/:3:0","tags":["GNU/Linux","Fedora"],"title":"Fedora 34 中无法修改无线网卡的 county code","uri":"/posts/2022-10-16-change-wifi-country-code-in-f34/"},{"categories":["运维","故障排除"],"content":"Reference e877342 Obsoleted by wireless-regdb ","date":"2022-10-16","objectID":"/posts/2022-10-16-change-wifi-country-code-in-f34/:4:0","tags":["GNU/Linux","Fedora"],"title":"Fedora 34 中无法修改无线网卡的 county code","uri":"/posts/2022-10-16-change-wifi-country-code-in-f34/"},{"categories":["故障排除"],"content":"症状 环境：Windows 10 x64 + NVIDIA RTX 2060 Mobile Visual Studio Code 界面部分或全部变得模糊。 鼠标点击模糊的位置，模糊的程度会改变。 ","date":"2022-10-16","objectID":"/posts/2022-10-16-windows10-vscode-blur/:1:0","tags":["Windows","Visual Studio Code"],"title":"Windows 10 Visual Studio Code 界面部分模糊的解决方案","uri":"/posts/2022-10-16-windows10-vscode-blur/"},{"categories":["故障排除"],"content":"解决方案 禁用FXAA\" 禁用FXAA 在NVIDIA 控制面板中，禁用FXAA。 全局设置 or 程序设置？ 不特定多个应用程序中发生模糊现象，或不需要针对所有程序启用FXAA，使用全局设置。 只需要解决特定应用程序中文本的模糊现象，使用程序设置。 ","date":"2022-10-16","objectID":"/posts/2022-10-16-windows10-vscode-blur/:2:0","tags":["Windows","Visual Studio Code"],"title":"Windows 10 Visual Studio Code 界面部分模糊的解决方案","uri":"/posts/2022-10-16-windows10-vscode-blur/"},{"categories":["故障排除"],"content":"参考文献 atom，vs2017、vscode 在 win10 下界面显示模糊怎么办？ - runner time的回答 - 知乎 ","date":"2022-10-16","objectID":"/posts/2022-10-16-windows10-vscode-blur/:3:0","tags":["Windows","Visual Studio Code"],"title":"Windows 10 Visual Studio Code 界面部分模糊的解决方案","uri":"/posts/2022-10-16-windows10-vscode-blur/"},{"categories":["运维"],"content":"症状 访问路由器管理界面，网页返回一行孤独的错误。 /usr/lib/lua/luci/dispatcher.lua:431: /etc/config/luci seems to be corrupt, unable to find section 'main' 可是刚刚还能正常登录，近期也没有进行什么特殊的设置。而且除了管理界面之外的其他功能都正常工作。 多亏了万能的搜索引擎，发现可能是 rpcd 死了，遂通过 SSH 连接至路由器。 root@Router:~# ps | grep rpc 1238 root 3812 S /sbin/rpcd -s /var/run/ubus/ubus.sock -t 30 4796 root 1316 S grep rpc 考虑到有的 rpcd 虽然活着，但它已经死了，仍然将其重启。 ","date":"2022-07-13","objectID":"/posts/2022-07-13-openwrt-luci-unable-to-find-section-main/:1:0","tags":["openWRT"],"title":"luci seems to be corrupt, unable to find section 'main'","uri":"/posts/2022-07-13-openwrt-luci-unable-to-find-section-main/"},{"categories":["运维"],"content":"解决方案 SSH 连接至路由器，执行下面的指令重启 rpcd。 service rpcd restart 尝试访问路由器管理界面，成功。 ","date":"2022-07-13","objectID":"/posts/2022-07-13-openwrt-luci-unable-to-find-section-main/:2:0","tags":["openWRT"],"title":"luci seems to be corrupt, unable to find section 'main'","uri":"/posts/2022-07-13-openwrt-luci-unable-to-find-section-main/"},{"categories":["运维"],"content":"Reference openwrt/luci#2231 ","date":"2022-07-13","objectID":"/posts/2022-07-13-openwrt-luci-unable-to-find-section-main/:3:0","tags":["openWRT"],"title":"luci seems to be corrupt, unable to find section 'main'","uri":"/posts/2022-07-13-openwrt-luci-unable-to-find-section-main/"},{"categories":["实用软件"],"content":"使用下面的指令将原始 m3u8 视频流原封不动的保存至 MKV 容器中，供后续处理。 ffmpeg -i \u003c指向m3u8文件的URL\u003e -c copy \u003c输出文件名\u003e.mkv ","date":"2022-07-13","objectID":"/posts/2022-07-13-one-line-cmd-m3u8/:0:0","tags":["CLI","ffmpeg"],"title":"一行命令使用 ffmpeg 下载 m3u8 视频流","uri":"/posts/2022-07-13-one-line-cmd-m3u8/"},{"categories":["音频视频"],"content":"现象 视频后半段明显的音画不同步 预览窗口中，当前位置波形与实际播放的声音内容不能对应 ","date":"2022-04-30","objectID":"/posts/2022-04-30-pr-aresample/:1:0","tags":["Premiere Pro","ffmpeg"],"title":"通过 ffmpeg 重新编码解决 Premiere Pro 导入可变帧速率视频后音画不同步的问题","uri":"/posts/2022-04-30-pr-aresample/"},{"categories":["音频视频"],"content":"产生原因 是由于视频采用了可变帧速率（VFR）技术而Pr对此支持并不完美所导致的。虽然自 Pr CC 2018 后，Pr本身已经对VFR有了一定的支持，但导入个别VFR视频仍然会产生音画不同步的现象。 ","date":"2022-04-30","objectID":"/posts/2022-04-30-pr-aresample/:2:0","tags":["Premiere Pro","ffmpeg"],"title":"通过 ffmpeg 重新编码解决 Premiere Pro 导入可变帧速率视频后音画不同步的问题","uri":"/posts/2022-04-30-pr-aresample/"},{"categories":["音频视频"],"content":"解决方案 使用 FFmpeg 将 VFR 视频转换为 CFR，并使用 -af aresample=async=1000 对音频进行重采样，确保音画同步。 ","date":"2022-04-30","objectID":"/posts/2022-04-30-pr-aresample/:3:0","tags":["Premiere Pro","ffmpeg"],"title":"通过 ffmpeg 重新编码解决 Premiere Pro 导入可变帧速率视频后音画不同步的问题","uri":"/posts/2022-04-30-pr-aresample/"},{"categories":["音频视频"],"content":"关键参数 位于 -i 前的 -vsync cfr 位于 -i 后的 -af aresample=async=1000 ","date":"2022-04-30","objectID":"/posts/2022-04-30-pr-aresample/:3:1","tags":["Premiere Pro","ffmpeg"],"title":"通过 ffmpeg 重新编码解决 Premiere Pro 导入可变帧速率视频后音画不同步的问题","uri":"/posts/2022-04-30-pr-aresample/"},{"categories":["音频视频"],"content":"示例：硬件加速编码 NVENC 推荐在安装有 NVIDIA 显卡时优先采用。 ffmpeg -vsync cfr -i \u003c输入视频\u003e -pix_fmt yuv420p -r \u003c目标帧率\u003e -c:v h264_nvenc -b:v \u003c视频码率\u003e -af aresample=async=1000 -b:a \u003c音频码率\u003e \u003c输出文件名\u003e.mp4 ","date":"2022-04-30","objectID":"/posts/2022-04-30-pr-aresample/:3:2","tags":["Premiere Pro","ffmpeg"],"title":"通过 ffmpeg 重新编码解决 Premiere Pro 导入可变帧速率视频后音画不同步的问题","uri":"/posts/2022-04-30-pr-aresample/"},{"categories":["运维","故障排除"],"content":"TL;DR 由于神秘原因，系统时间穿越到了3822年，使得explorer.exe 不断崩溃重启。将时间修改为20xx年后恢复正常。 ","date":"2022-04-30","objectID":"/posts/2022-04-30-3800-windows-explorer/:0:0","tags":["Windows"],"title":"来自 3800s 的 Windows 10","uri":"/posts/2022-04-30-3800-windows-explorer/"},{"categories":["运维","故障排除"],"content":"正文 最近帮人排除电脑疑难杂症的时候发现了 Windows Explorer 的一个神奇的BUG：如果系统时间被调节为38xx年，explorer.exe 就会不停的崩溃重启。 ","date":"2022-04-30","objectID":"/posts/2022-04-30-3800-windows-explorer/:1:0","tags":["Windows"],"title":"来自 3800s 的 Windows 10","uri":"/posts/2022-04-30-3800-windows-explorer/"},{"categories":["运维","故障排除"],"content":"具体表现 安全模式下任务栏闪烁 鼠标焦点以固定的频率失去 30%左右的CPU占用，风扇狂转 任务管理器中拒绝访问的 explorer.exe ","date":"2022-04-30","objectID":"/posts/2022-04-30-3800-windows-explorer/:2:0","tags":["Windows"],"title":"来自 3800s 的 Windows 10","uri":"/posts/2022-04-30-3800-windows-explorer/"},{"categories":["运维","故障排除"],"content":"后续 通过将系统日期修改为正常的日期可以解决该问题。目前还没有尝试复现，因为我发现控制面板里的日期和时间设置最多只能改到2099年。 根据反馈，可能是使用 H3C iNode 进行连接的过程中，由于 iNode 自身的BUG造成的。重置 （也有可能是重装） iNode 配置后该问题不再出现。 ","date":"2022-04-30","objectID":"/posts/2022-04-30-3800-windows-explorer/:3:0","tags":["Windows"],"title":"来自 3800s 的 Windows 10","uri":"/posts/2022-04-30-3800-windows-explorer/"},{"categories":["手机"],"content":"危险 不当操作可能对您的设备和数据造成不可逆的损害。 某日心血来潮，拿着刚刷入 Android12 的 OnePlus 5T，在 开发者选项-\u003e刘海屏 中随便点了一个，想着体验一下所谓“刘海屏”到底有多么的丑陋。手机卡顿了一下，屏幕一黑，再就没有亮起。 强制重启后，开机动画一过，立马黑屏。好在 DerpFest 自带的 FPS Overlay 仍然倔强的显示在屏幕的左上角，长按电源键有震动，提醒我系统还是在工作的，只是因为模拟刘海屏的原因无法正常的显示出来而已。只要能关闭模拟刘海屏，便能恢复正常显示。 根据上述症状，确定解决问题的思路：通过外部手段关闭模拟刘海屏。有三种实现方式： 使用ADB在线关闭模拟刘海屏 使用 TWRP Recovery 离线访问系统文件，关闭模拟刘海屏 双清（所有数据灰飞烟灭） ","date":"2022-01-23","objectID":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/:0:0","tags":["ADB"],"title":"拯救因开启刘海屏模拟而黑屏的手机","uri":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/"},{"categories":["手机"],"content":"0x00 进入 ADB Shell 由于之前通过ADB连接电脑时勾选了“一律允许此计算机进行调试”，用USB连上电脑后立刻就在 adb devices 中看到了处于 device 状态的手机。 无法通过ADB连接到电脑，怎么办？ 很遗憾，即使已经在开发者选项中开启了 ADB 调试，但没有使用勾选过“一律允许此计算机进行调试”的电脑进行连接，需要在手机屏幕上手动点击确定，否则设备将处于无法通过ADB进行操作的 unauthorized 状态。 对于无法自动连接的状况，只能另寻他法。 立即快进到交互式 ADB Shell! adb shell ","date":"2022-01-23","objectID":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/:1:0","tags":["ADB"],"title":"拯救因开启刘海屏模拟而黑屏的手机","uri":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/"},{"categories":["手机"],"content":"0x01 通过 ADB Shell 关闭模拟刘海屏 信息 本节中所有命令在 ADB Shell 中运行。对于 OnePlus 5T，终端提示符形如：dumpling:/ $ 起初使用 settings list, 在三大名字空间中 {system, secure, global} 苦苦寻找，也没有找到带 cutout 字眼的设置项。部分机型可通过此方式找到掌管模拟刘海屏的设置项。1 后来根据 Reference 中所述方法，通过禁用用于模拟刘海屏的叠加层 (Overlay) 来使模拟刘海屏的设置无效化。使用下列命令筛选需要禁用的叠加层: cmd overlay list | grep cutout 找到需要禁用的 Overlay\" 找到需要禁用的 Overlay [x] 开头的行就是当前已启用的用于模拟刘海屏的叠加层，本例中为 com.android.internal.display.cutout.emulation.wide，使用下列指令禁用之。 cmd overlay disable \u003cPACKAGE_NAME\u003e 按下回车后手机当场起死回生，恢复了正常的显示。 ","date":"2022-01-23","objectID":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/:2:0","tags":["ADB"],"title":"拯救因开启刘海屏模拟而黑屏的手机","uri":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/"},{"categories":["手机"],"content":"0x02 其他理论上的方法 ","date":"2022-01-23","objectID":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/:3:0","tags":["ADB"],"title":"拯救因开启刘海屏模拟而黑屏的手机","uri":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/"},{"categories":["手机"],"content":"TWRP 警告 该方法未经实践检验。 进入 TWRP 后挂在 system 和/或 vendor，进入下列路径之一（如果有） /system/system/product/overlay /vendor/overlay 搜索并删除一切和 cutout 有关的内容。 ","date":"2022-01-23","objectID":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/:3:1","tags":["ADB"],"title":"拯救因开启刘海屏模拟而黑屏的手机","uri":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/"},{"categories":["手机"],"content":"双清 寄 寄 又称恢复出厂设置，丢失几十个GB的数据，几分钟后又是一台好机。 ","date":"2022-01-23","objectID":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/:3:2","tags":["ADB"],"title":"拯救因开启刘海屏模拟而黑屏的手机","uri":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/"},{"categories":["手机"],"content":"Reference Warning - do not change Display cutout in Developer Settings! - Reddit u/Allen_cl’s replay - Reddit ↩︎ ","date":"2022-01-23","objectID":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/:4:0","tags":["ADB"],"title":"拯救因开启刘海屏模拟而黑屏的手机","uri":"/posts/2022-01-23-fix-black-screen-after-change-cutout-emulation-option/"},{"categories":["代码"],"content":"将下列内容添加到 .gitconfig 中 # Comment: Start of \"Extra Block\" # Comment: To unlock Visual Studio Code as your Git diff and Git merge tool [merge] tool = vscode [mergetool \"vscode\"] cmd = code --wait $MERGED [diff] tool = vscode [difftool \"vscode\"] cmd = code --wait --diff $LOCAL $REMOTE # Comment: End of \"Extra Block\" ","date":"2021-01-23","objectID":"/posts/2021-01-23-config-vsc-as-defufault-mergetool/:0:0","tags":["git","Visual Studio Code"],"title":"配置 Visual Studio Code 作为 Git 默认合并工具和对比工具","uri":"/posts/2021-01-23-config-vsc-as-defufault-mergetool/"},{"categories":["代码"],"content":"参考文献 How to use Visual Studio Code as the default editor for Git MergeTool - Stack Overflow ","date":"2021-01-23","objectID":"/posts/2021-01-23-config-vsc-as-defufault-mergetool/:1:0","tags":["git","Visual Studio Code"],"title":"配置 Visual Studio Code 作为 Git 默认合并工具和对比工具","uri":"/posts/2021-01-23-config-vsc-as-defufault-mergetool/"},{"categories":["运维"],"content":"使用 chmod -R 递归修改权限的时候会把文件和目录的权限都修改了，可有时候我们只想修改目录的权限，便不能直接用 chmod -R 修改。由于 chmod 命令不支持分别对文件或目录进行操作，因此我们需要借助 find 命令来分别筛选出待处理的文件或目录，并通过 xargs 将需要修改权限的对象传递给 chmod 进行修改。 本文以分别将 /path/to/base/dir 目录下所有文件的权限指定为644，所有目录的权限指定为755为例。 # 修改目录权限 find /path/to/base/dir -type d -print0 | xargs -r -0 chmod 755 # 修改文件权限 find /path/to/base/dir -type f -print0 | xargs -r -0 chmod 644 理论上，本方法可适用于大量1文件/目录。 -r 2参数使得如果 find 没有找到符合要求的对象则 xargs 不会执行 chmod 命令。 ","date":"2021-01-17","objectID":"/posts/2021-01-17-recursively-chmod-all-directories-except-files/:0:0","tags":["GNU/Linux"],"title":"使用 find + chmod 批量修改目录或文件的权限","uri":"/posts/2021-01-17-recursively-chmod-all-directories-except-files/"},{"categories":["运维"],"content":"参考文献 How to recursively chmod all directories except files? - Super User man find man xargs ","date":"2021-01-17","objectID":"/posts/2021-01-17-recursively-chmod-all-directories-except-files/:1:0","tags":["GNU/Linux"],"title":"使用 find + chmod 批量修改目录或文件的权限","uri":"/posts/2021-01-17-recursively-chmod-all-directories-except-files/"},{"categories":["运维"],"content":"脚注 comment1864697_91938 by: Agargara ↩︎ 等效于 --no-run-if-empty，详情参考 xargs 手册。 ↩︎ ","date":"2021-01-17","objectID":"/posts/2021-01-17-recursively-chmod-all-directories-except-files/:2:0","tags":["GNU/Linux"],"title":"使用 find + chmod 批量修改目录或文件的权限","uri":"/posts/2021-01-17-recursively-chmod-all-directories-except-files/"},{"categories":["运维"],"content":"本文以 ASUS K42Jv 笔记本为例，主要介绍在 GNU/Linux 系统中设置自动开机的一种方法，内容偏重于实际操作，关于 RTC Clock 的原理则一笔带过，并不再赘述自动开机是什么为什么要自动开机自动开机在哪里等尽人皆知的话题。 部分文章1认为 RTC Clock 唤醒是一种落后的技术，且不可靠。本文不探讨唤醒方式是否可靠的问题，劳烦读者自行试验。 ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:0:0","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"什么情况下可以使用 RTC Clock 来实现自动开机？ 无法通过 BIOS 设置界面配置自动开机。 不具备配置 Wake on LAN 的条件（比如无网络连接，各种原因无发送唤醒数据包等情况） 主板支持 RTC Clock ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:1:0","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"我的电脑支持 RTC Clock Wakeup 吗？ 查看内核日志，不同发行版的操作可能略有不同。 # Ubuntu grep -i rtc /var/log/kern.log # Ubuntu with systemd sudo journalctl | grep rtc 应该有类似下方的输出。 rtc_cmos 00:03: RTC can wake from S4 ... rtc_cmos 00:03: rtc core: registered rtc_cmos as rtc0 亲自测试是否支持 RTC Clock Wakeup 俗话说实践是检验真理的唯一标准，我们通过一个简单的小脚本来测试你的电脑是否能够通过 RTC Clock 自动唤醒。记得使用 ROOT 权限执行。 #!/bin/bash # RUN AS ROOT! echo 0 \u003e /sys/class/rtc/rtc0/wakealarm echo +180 \u003e /sys/class/rtc/rtc0/wakealarm poweroff 如果一切顺利，你的电脑将在3分钟（180秒）后自动开机。 如果你的电脑没有按照预期开机，不妨试试把 +180 修改为 $(date '+%s' -d '+ 3 minutes')，即传入需要自动开机时间的时间戳。 ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:2:0","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"利用 RTC Clock 配置自动开机 ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:3:0","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"准备工作：关闭硬件时钟更新（可选） 警告 目前尚不清楚在关机时系统对硬件时钟进行更新是否会对自动唤醒产生影响。如需尝试关闭，可参考Disable hwclock updates。 本文所使用案例之 BIOS 时钟设置为本地时区时间而非UTC时间。 ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:3:1","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"检查自动开机状态 执行以下命令获取当前RTC时钟的详细信息。 cat /proc/driver/rtc 输出示例如下 rtc_time : 22:17:23 rtc_date : 2021-01-30 alrm_time : 17:24:15 alrm_date : 2021-01-31 alarm_IRQ : no alrm_pending : no update IRQ enabled : no periodic IRQ enabled : no periodic IRQ frequency : 1024 max user IRQ frequency : 64 24hr : yes periodic_IRQ : no update_IRQ : no HPET_emulated : no BCD : yes DST_enable : no periodic_freq : 1024 batt_status : okay 名称 值 说明 rtc_time hh:mm:ss RTC时间（硬件时钟/CMOS时间） rtc_data yyyy-mm-dd RTC日期（硬件时钟/CMOS日期） alrm_time hh:mm:ss 自动开机时间 alrm_date yyyy-mm-dd 自动开机日期 alarm_IRQ yes/no 指示是否设置了自动开机 ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:3:2","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"手动设置自动开机 echo +$wakeup_time \u003e /sys/class/rtc/rtc0/wakealarm $wakeup_time 的数值与格式根据不同的主板可能略有差异。在Linux.com上的某篇2教程中为需要自动开机时间的时间戳且开头没有+，但在部分 ASUS3 笔记本上必须传入需要自动开机的时间与当前时间的时间戳之差（也可以理解为经过指定秒数后自动开机）才能成功设置自动开机。 执行完该设置指令后无任何回显，需要检查 alarm_IRQ 的值是否为 yes 来判断设置是否成功。 如果传入的 wakeup_time 值为0，则取消之前设置的自动开机时间。 ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:3:3","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"使用 Shell 脚本 使用 Bash 脚本将时间换算为秒的工作交给计算机完成。下列例子借助 date 将用户输入的时间与当前时间做差，并将结果换算为秒数，最终传递给 /sys/class/rtc/rtc0/wakealarm。 信息 脚本可能需要根据实际情况进行修改。下方脚本仅供示例，在 ASUS K42jv with Ubuntu 18.04 上测试可用。 #!/bin/bash # RUN AS ROOT! read -p \"输入自动开机时间:\" d1 t1=$(date \"+%s\") t2=$(date -d \"$d1\" \"+%s\") t3=$(($t2-$t1)) echo $t3 echo +$t3 \u003e /sys/class/rtc/rtc0/wakealarm cat /proc/driver/rtc ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:3:4","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["运维"],"content":"参考文献和注释 ACPI Wakeup - MythTV Official Wiki Wake up and Shut Down Linux Automatically - Linux.com ↩︎ Wake Up Linux With an RTC Alarm Clock - Linux.com ↩︎ Bug 12013 - /sys/class/rtc/rtc0/wakealarm doesn’t work, while /proc/acpi/alarm works - Asus P2-M2A690G ↩︎ ","date":"2020-02-03","objectID":"/posts/2020-02-03-autowakeup-by-rtc/:4:0","tags":["GNU/Linux","Ubuntu"],"title":"ASUS 笔记本使用 RTC Clock 设置 GNU/Linux 系统的自动开机","uri":"/posts/2020-02-03-autowakeup-by-rtc/"},{"categories":["实用软件"],"content":"在 Gnome 桌面环境下，刚装完 Kdenlive 时如果默认为白的发丑的界面，而且“主题”菜单下还只有一个“默认”，说明你的系统还没有安装适用于KDE桌面环境的主题。 执行下面的指令安装 kde-style-breeze-qt4，再打开 Kdenlive 就能在主题菜单下找到 Breeze Dark 主题了。 sudo apt install kde-style-breeze-qt4 安装其他KDE主题同理。 ","date":"2019-09-09","objectID":"/posts/2019-09-09-install-dark-theme-for-kdenlive/:0:0","tags":["GNU/Linux","KDE","Ubuntu"],"title":"在 Ubuntu 18.04 中为 Kdenlive 安装黑色主题","uri":"/posts/2019-09-09-install-dark-theme-for-kdenlive/"},{"categories":["运维"],"content":"为啥 /mnt/hgfs 空空如也？是配置的失误还是软件的故障？今晚8点，《社会与法》，准时播出 ","date":"2018-09-24","objectID":"/posts/2018-09-24-setup-vmware-tool-hgfs/:0:0","tags":["Ubuntu","VMware","虚拟机"],"title":"Ubuntu 18.04 配置 VMware 的共享文件夹功能","uri":"/posts/2018-09-24-setup-vmware-tool-hgfs/"},{"categories":["运维"],"content":"环境 宿主机：Windows 10 客户机：Ubuntu 18.04 ","date":"2018-09-24","objectID":"/posts/2018-09-24-setup-vmware-tool-hgfs/:1:0","tags":["Ubuntu","VMware","虚拟机"],"title":"Ubuntu 18.04 配置 VMware 的共享文件夹功能","uri":"/posts/2018-09-24-setup-vmware-tool-hgfs/"},{"categories":["运维"],"content":"安装 open-vm-tools 本人尝试了十万甚至九万次仍然没能成功安装 vmware-tools ，故改用官方推荐的 open-vm-tools。 已经安装过的可以跳过此步。 sudo apt install open-vm-tools open-vm-tools-desktop fuse reboot 你知道吗 open-vm-tools-desktop 用于提供硬件加速、自适应分辨率和文件双向拖放等桌面环境下可能会用到的特性 Ubuntu 18.04 默认的软件源中没有 open-vm-tools-dkms ,但事实证明不装也不影响使用文件共享。 ","date":"2018-09-24","objectID":"/posts/2018-09-24-setup-vmware-tool-hgfs/:2:0","tags":["Ubuntu","VMware","虚拟机"],"title":"Ubuntu 18.04 配置 VMware 的共享文件夹功能","uri":"/posts/2018-09-24-setup-vmware-tool-hgfs/"},{"categories":["运维"],"content":"测试 如果能成功执行下列指令并能正常存取 /mnt/hgfs ，说明你的客户机已经完全支持存取宿主机的共享文件夹。下一步便是配置自动挂载了。 sudo vmhgfs-fuse -o allow_other .host:/ /mnt/hgfs ","date":"2018-09-24","objectID":"/posts/2018-09-24-setup-vmware-tool-hgfs/:3:0","tags":["Ubuntu","VMware","虚拟机"],"title":"Ubuntu 18.04 配置 VMware 的共享文件夹功能","uri":"/posts/2018-09-24-setup-vmware-tool-hgfs/"},{"categories":["运维"],"content":"配置自动挂载 向 /etc/fstab 尾部添加如下内容。 .host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0 不出意外的话，重启后即可在 /mnt/hgfs 中看到已设置为共享的宿主机文件夹了。 ","date":"2018-09-24","objectID":"/posts/2018-09-24-setup-vmware-tool-hgfs/:4:0","tags":["Ubuntu","VMware","虚拟机"],"title":"Ubuntu 18.04 配置 VMware 的共享文件夹功能","uri":"/posts/2018-09-24-setup-vmware-tool-hgfs/"},{"categories":["运维"],"content":"参考文献 Ubuntu中安装虚拟工具条open-vm-tools 在 VMware 虚拟机中安装 open-vm-tools ","date":"2018-09-24","objectID":"/posts/2018-09-24-setup-vmware-tool-hgfs/:5:0","tags":["Ubuntu","VMware","虚拟机"],"title":"Ubuntu 18.04 配置 VMware 的共享文件夹功能","uri":"/posts/2018-09-24-setup-vmware-tool-hgfs/"},{"categories":["运维"],"content":"WSL Config (wslconfig.exe) 是一个用来管理运行于 Windows上Linux子系统 中 Linux 发行版的命令行工具。你可以用它列出当前已安装的Linux发行版、设置默认使用的发行版或者卸载发行版。 ","date":"2018-06-10","objectID":"/posts/2018-06-10-wslconfig-usage/:0:0","tags":["GNU/Linux","WSL","Windows"],"title":"使用 wslconfig 管理 Windows10 Linux 子系统","uri":"/posts/2018-06-10-wslconfig-usage/"},{"categories":["运维"],"content":"如何使用 查看所有可用的选项，运行下面的指令： wslconfig /? wslconfig.exe Performs administrative operations on Windows Subsystem for Linux Usage: /l, /list [/all] - Lists registered distributions. /all - Optionally list all distributions, including distributions that are currently being installed or uninstalled. /s, /setdefault \u003cDistributionName\u003e - Sets the specified distribution as the default. /u, /unregister \u003cDistributionName\u003e - Unregisters a distribution. ","date":"2018-06-10","objectID":"/posts/2018-06-10-wslconfig-usage/:1:0","tags":["GNU/Linux","WSL","Windows"],"title":"使用 wslconfig 管理 Windows10 Linux 子系统","uri":"/posts/2018-06-10-wslconfig-usage/"},{"categories":["运维"],"content":"列出已安装的发行版 列出当前已经安装且随时可用的发行版： wslconfig /list 列出所有发行版，包括正在安装、卸载和已损坏的发行版： wslconfig /list /all ","date":"2018-06-10","objectID":"/posts/2018-06-10-wslconfig-usage/:2:0","tags":["GNU/Linux","WSL","Windows"],"title":"使用 wslconfig 管理 Windows10 Linux 子系统","uri":"/posts/2018-06-10-wslconfig-usage/"},{"categories":["运维"],"content":"设置默认发行版 wslconfig /setdefault \u003cDistributionName\u003e ","date":"2018-06-10","objectID":"/posts/2018-06-10-wslconfig-usage/:3:0","tags":["GNU/Linux","WSL","Windows"],"title":"使用 wslconfig 管理 Windows10 Linux 子系统","uri":"/posts/2018-06-10-wslconfig-usage/"},{"categories":["运维"],"content":"反注册（卸载）一个发行版 尽管可以通过 Windows应用商店 安装适用于WSL的Linux发行版，但不能通过应用商店卸载。WSL Config 使您能够卸载它们。 卸载后也可以在 Windows应用商店 重新安装发行版。 警告 注意: 卸载发行版时，会永久删除所有与该发行版有关的数据和设置。 用法： wslconfig /unregister \u003cDistributionName\u003e 示例：wslconfig /unregister Ubuntu 会将 Ubuntu 从当前可用的WSL发行版中彻底删除，之后运行 wslconfig /list 时该发行版便不会被列出。该发行版所占用的磁盘空间也会被释放。 ","date":"2018-06-10","objectID":"/posts/2018-06-10-wslconfig-usage/:4:0","tags":["GNU/Linux","WSL","Windows"],"title":"使用 wslconfig 管理 Windows10 Linux 子系统","uri":"/posts/2018-06-10-wslconfig-usage/"},{"categories":["运维"],"content":"参考资料 Manage and configure WSL ","date":"2018-06-10","objectID":"/posts/2018-06-10-wslconfig-usage/:5:0","tags":["GNU/Linux","WSL","Windows"],"title":"使用 wslconfig 管理 Windows10 Linux 子系统","uri":"/posts/2018-06-10-wslconfig-usage/"},{"categories":["实用软件"],"content":"shell命令行下有 md5sum 、 sha1sum 和sha256sum等应用广泛的文件校验和实用程序，下面就以时下流行的 sha1sum 为例介绍如何批量创建和校验文件校验和。 ","date":"2018-04-23","objectID":"/posts/2018-04-23-sha1sum-example/:0:0","tags":["CLI","CentOS","GNU/Linux"],"title":"用sha1sum批量校验文件完整性","uri":"/posts/2018-04-23-sha1sum-example/"},{"categories":["实用软件"],"content":"创建校验和 创建当前文件夹下所有文件的校验和并保存至 example.sha1 ： sha1sum * \u003e example.sha1 ","date":"2018-04-23","objectID":"/posts/2018-04-23-sha1sum-example/:0:1","tags":["CLI","CentOS","GNU/Linux"],"title":"用sha1sum批量校验文件完整性","uri":"/posts/2018-04-23-sha1sum-example/"},{"categories":["实用软件"],"content":"验证校验和 校验example.sha1中列出的文件： sha1sum -c example.sha1 ","date":"2018-04-23","objectID":"/posts/2018-04-23-sha1sum-example/:0:2","tags":["CLI","CentOS","GNU/Linux"],"title":"用sha1sum批量校验文件完整性","uri":"/posts/2018-04-23-sha1sum-example/"},{"categories":["实用软件"],"content":"参考文献 How do I check the SHA1 hash of a file? - Ask Ubuntu ","date":"2018-04-23","objectID":"/posts/2018-04-23-sha1sum-example/:0:3","tags":["CLI","CentOS","GNU/Linux"],"title":"用sha1sum批量校验文件完整性","uri":"/posts/2018-04-23-sha1sum-example/"},{"categories":["实用软件"],"content":"Google搜索下面四个RPM包然后rpm -ivh安装即可 gettext-common-devel-0.18.1.1-7.18.noarch gettext-libs-0.18.1.1-7.18.x86_64 gettext-devel-0.18.1.1-7.18.x86_64 gettext-0.18.1.1-7.18.x86_64 ","date":"2017-12-09","objectID":"/posts/2017-12-09-install-gettext-centos6/:0:0","tags":["CentOS","GNU/Linux"],"title":"在CentOS 6上使用rpm安装gettext-0.18","uri":"/posts/2017-12-09-install-gettext-centos6/"},{"categories":["代码"],"content":"众所周知 PyInstaller 可以将 Python 脚本打包成单一的可执行文件，那么如果程序需要访问自带的外部资源时该怎么办呢？ ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:0:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"封装资源文件的必要性 制作绿色便携的单EXE可执行文件 有些文件不希望让最终用户轻易看到 干净 ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:1:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"目录 封装资源文件的必要性 目录 建立配置文件 编辑配置文件 datas Tree 修改代码引用 编译 参考资料 额外说明 ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:2:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"建立配置文件 键入下列指令建立spec配置文件，参数与直接使用PyInstaller时使用的参数相同，程序会自动帮你添加到配置文件中。 pyi-makespec -F -w –icon=\u003cYourICON\u003e.ico \u003cYourPyScript\u003e 使用类似pyinstaller -F XXX.spec编译二进制程序时添加的参数可能没有效果。 ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:3:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"编辑配置文件 依据实际情况添加配置文件的引用。 ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:4:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"datas 此法适用于添加单个或几个文件 找到Analysis()的datas=[]，每个文件一个tuple（元组）格式如下： a = Analysis( ... datas=[('文件在当前系统中的位置','文件在可执行文件运行时相对于可执行文件的位置')], ... ) 使用通配符可以同时添加所有匹配的文件 a = Analysis( ... datas= [ ('/mygame/sfx/*.mp3', 'sfx' ) ], ... ) 更多高级用法请阅读PyInstaller文档（英文）：Adding Data Files ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:4:1","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"Tree 此法适用于添加一整个目录的文件 首先，在spec文件中添加如下内容： extra_tree = Tree('./myimages', prefix = 'myimages') 然后在 a.scripts 等 a. 开头文件所在的部分后添加 extra_tree。 表示还没有深入理解Tree，先复制粘贴了其他神触的步骤。 更多高级用法请阅读PyInstaller文档（英文）：The Tree Class ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:4:2","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"修改代码引用 在脚本开头添加下列代码： import sys, os if getattr(sys, 'frozen', False): # 运行于 |PyInstaller| 二进制环境 basedir = sys._MEIPASS else: # 运行于一般Python 环境 basedir = os.path.dirname(__file__) 找到所有涉及相对路径的文件操作，在路径前添加basedir+。示例： with open(os.path.normpath(basedir + '\\\\ui.kv'), 'r', encoding='UTF-8') as f1: kv_str = f1.read() 其中 os.path.normpath() 用于标准化路径。详细信息请自行查阅 Python 文档。 经此法修改的脚本可同时在单exe和使用解释器运行时使用相对路径读取打包的资源文件。 ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:5:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"编译 接下来的步骤就比较轻松了，直接使用PyInstaller编译然后到./dict文件夹中找到你刚编译出来的可执行文件即可。 pyinstaller \u003cYourPyScript\u003e.spec ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:6:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"参考资料 PyInstaller打包单个bundle时封装额外的资源文件 ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:7:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["代码"],"content":"额外说明 [CRITICAL] [Window ] Unable to find any valuable Window provider. 如果要打包的程序使用了Kivy框架，则spec文件需做点修改，否则打包出的EXE由于依赖缺失无法正常加载窗口。 # spec文件头部添加 from kivy.deps import sdl2, glew #修改EXE(),添加需在**第一个关键词参数的前面**进行。 exe = EXE( ... *[Tree(p) for p in(sdl2.dep_bins + glew.dep_bins)], ... ) ","date":"2017-12-02","objectID":"/posts/2017-12-02-pyinstaller-openbasedir/:8:0","tags":["Python","PyInstaller"],"title":"PyInstaller打包单EXE时封装额外的资源文件","uri":"/posts/2017-12-02-pyinstaller-openbasedir/"},{"categories":["故障排除"],"content":"虽然时至今日 Vim 对中文的支持已经改善了许多，但仍有可能遇到极端个案，不是么？ Shell运行下列指令： echo \"set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936\\nset termencoding=utf-5\\nset encoding=utf-8\" \u003e\u003e ~/.vimrc 原理为向 .vimrc 中添加和文字编码处理有关的配置项。理论上适用于任何环境中的vim。 ","date":"2017-11-29","objectID":"/posts/2017-11-29-fix-termux-vim-fileencodings/:0:0","tags":null,"title":"解决 vim 显示中文乱码的问题","uri":"/posts/2017-11-29-fix-termux-vim-fileencodings/"},{"categories":["故障排除"],"content":"参考文章 http://www.cnblogs.com/joeyupdo/archive/2013/03/03/2941737.html ","date":"2017-11-29","objectID":"/posts/2017-11-29-fix-termux-vim-fileencodings/:0:1","tags":null,"title":"解决 vim 显示中文乱码的问题","uri":"/posts/2017-11-29-fix-termux-vim-fileencodings/"},{"categories":["实用软件"],"content":"已知问题： 十万甚至九万年后的今天，这个版本估计早已无法使用。 没有例如专栏、消息等花哨的新版特性 由于陈睿关闭了旧有的缓存接口（403 Forbidden），支持离线blv格式视频版本以前版本的客户端将无法缓存视频。故该版本客户端缓存的是blv格式视频。 下载地址 Onedirve ","date":"2017-11-18","objectID":"/posts/2017-11-18-bilineta-client/:0:0","tags":null,"title":"bilibili Android 5.2.0 客户端 with BiliNeta 1.9.5","uri":"/posts/2017-11-18-bilineta-client/"},{"categories":["手机"],"content":"好像现在不需要这么麻烦了，此文章仅供存档。 ","date":"2017-08-11","objectID":"/posts/2017-08-11-install-gevent/:0:0","tags":["Terumx","Python"],"title":"Termux 中安装 gevent 库","uri":"/posts/2017-08-11-install-gevent/"},{"categories":["手机"],"content":"引言 偶然在网上发现了一个暴力扫描二级域名的Python2神器：subDomainsBrute 这个神器必须由 Python2.7 强力驱动，同时还需要 dnspython 和 gevent 两个Python库。为了实现“电脑手机随时随地爆域名”，安装这两个库是必不可少的步骤。 ","date":"2017-08-11","objectID":"/posts/2017-08-11-install-gevent/:1:0","tags":["Terumx","Python"],"title":"Termux 中安装 gevent 库","uri":"/posts/2017-08-11-install-gevent/"},{"categories":["手机"],"content":"准备工作 在Linux系统（或者Termux）中安装gevent前请务必确保您安装了 gcc 和 python-dev，不然会发生一些谜之错误。 ","date":"2017-08-11","objectID":"/posts/2017-08-11-install-gevent/:2:0","tags":["Terumx","Python"],"title":"Termux 中安装 gevent 库","uri":"/posts/2017-08-11-install-gevent/"},{"categories":["手机"],"content":"正文 电脑上安装 dnspython 和 gevent 的过程会被pip瞬间完成，可在 Termux 上安装时，dnspython 倒是瞬间完成了，gevent 会出现下面的错误。 Installing collected packages: gevent Running setup.py install for gevent ... error 中间省略....... copying src/gevent/libev/stathelper.c -\u003e build/lib.linux-aarch64-2.7/gevent/libev running build_ext Running '(cd \"/data/data/com.termux/files/usr/tmp/pip-build-wanBBe/gevent/deps/libev\" \u0026\u0026 sh ./configure \u0026\u0026 cp config.h \"$OLDPWD\" ) \u003e configure-output.txt' in /data/data/com.termux/files/usr/tmp/pip-build-wanBBe/gevent/build/temp.linux-aarch64-2.7/libev ./configure: 1: eval: /bin/sh: not found configure: WARNING: 'missing' script is too old or missing configure: error: cannot run /bin/sh ./config.sub Traceback (most recent call last): File \"\u003cstring\u003e\", line 1, in \u003cmodule\u003e File \"/data/data/com.termux/files/usr/tmp/pip-build-wanBBe/gevent/setup.py\", line 183, in \u003cmodule\u003e run_setup(EXT_MODULES, run_make=_BUILDING) .....省略 File \"/data/data/com.termux/files/usr/lib/python2.7/subprocess.py\", line 186, in check_call raise CalledProcessError(retcode, cmd) subprocess.CalledProcessError: Command '(cd \"/data/data/com.termux/files/usr/tmp/pip-build-wanBBe/gevent/deps/libev\" \u0026\u0026 sh ./configure \u0026\u0026 cp config.h \"$OLDPWD\" ) \u003e configure-output.txt' returned non-zero exit status 127 ---------------------------------------- Command \"/data/data/com.termux/files/usr/bin/python2 -u -c \"import setuptools, tokenize;__file__='/data/data/com.termux/files/usr/tmp/pip-build-wanBBe/gevent/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\\r\\n', '\\n');f.close();exec(compile(code, __file__, 'exec'))\" install --record /data/data/com.termux/files/usr/tmp/pip-U_0ve9-record/install-record.txt --single-version-externally-managed --compile\" failed with error code 1 in /data/data/com.termux/files/usr/tmp/pip-build-wanBBe/gevent/ 看来是configure程序找不到 /bin/sh 了，要知道在Termux中这个目录可不在这个地方。解决方法也很简单，在安装gevent之前键入下列指令： export CONFIG_SHELL=$PREFIX/bin/sh 然后重新用pip安装gevent，不出意外的话便能正常完成安装。 ","date":"2017-08-11","objectID":"/posts/2017-08-11-install-gevent/:3:0","tags":["Terumx","Python"],"title":"Termux 中安装 gevent 库","uri":"/posts/2017-08-11-install-gevent/"},{"categories":["手机"],"content":"参考资料 /bin/sh: not found · Issue #104 · termux/termux-app ","date":"2017-08-11","objectID":"/posts/2017-08-11-install-gevent/:4:0","tags":["Terumx","Python"],"title":"Termux 中安装 gevent 库","uri":"/posts/2017-08-11-install-gevent/"},{"categories":["代码"],"content":"从jb51.net上抄的脚本，本人对其略加改造。","date":"2017-07-25","objectID":"/posts/2017-07-25-a-simple-js-countdown-script/","tags":["JavaScript"],"title":"自用倒计时js脚本","uri":"/posts/2017-07-25-a-simple-js-countdown-script/"},{"categories":["代码"],"content":"从jb51.net上抄的脚本，本人对其略加改造。 function getRTime(CustomTime,Tid){ var EndTime= new Date(CustomTime); var NowTime = new Date(); var t =EndTime.getTime() - NowTime.getTime(); var d=0; var h=0; var m=0; var s=0; var text; if(t\u003e=0){ d=Math.floor(t/1000/60/60/24) h=Math.floor(t/1000/60/60%24); m=Math.floor(t/1000/60%60); s=Math.floor(t/1000%60); } /*总写入*/ text = d + \"天\u0026nbsp;\" + h + \"小时\u0026nbsp;\" + m + \"分钟\u0026nbsp;\" + s + \"秒\"; document.getElementById(Tid).innerHTML=text; var ff=\"getRTime('\"+CustomTime+\"','\"+Tid+\"')\" setTimeout(ff,1000) } ","date":"2017-07-25","objectID":"/posts/2017-07-25-a-simple-js-countdown-script/:0:0","tags":["JavaScript"],"title":"自用倒计时js脚本","uri":"/posts/2017-07-25-a-simple-js-countdown-script/"},{"categories":["代码"],"content":"使用方法 在文档加载完成后调用一次GetRTime('yourCustomTime'，'DisplayElementID')函数即可。 参数1为目标时间，格式推荐YY/MM/DD hh:mm:ss或者其他可被Date对象接受的格式；参数2为展示倒计时内容的HTML标签的ID。 ","date":"2017-07-25","objectID":"/posts/2017-07-25-a-simple-js-countdown-script/:0:1","tags":["JavaScript"],"title":"自用倒计时js脚本","uri":"/posts/2017-07-25-a-simple-js-countdown-script/"},{"categories":["代码"],"content":"示例 距离2017年暑假还有：\u003cspan id=\"HT\" style=\"color:red;\"\u003e\u003c/span\u003e GetRTime('2017/7/14','HT'); ","date":"2017-07-25","objectID":"/posts/2017-07-25-a-simple-js-countdown-script/:0:2","tags":["JavaScript"],"title":"自用倒计时js脚本","uri":"/posts/2017-07-25-a-simple-js-countdown-script/"},{"categories":["手机"],"content":"最近搞了一台iPhone4S，准备降级至iOS6.1.3，结果各种卡sending IBSS以及255错误。在观看了许多帖子后自己整理出了一个降级的详细条件，只有满足每个条件才可能成功降级。 越狱 无设备锁（关闭查找我的iPhone） 使用软件方法进入DFU，而不是手动进入。（SSH或红V插件，效果相同） 使用处理过的 ispw 文件，通常都会随工具包附带。 顺便附上在网络上搜集的工具包 链接: https://pan.baidu.com/s/1WW6oFhE9P0iT5k8iJHRoPA 提取码: akes ","date":"2017-04-15","objectID":"/posts/2017-04-15-iphone4sdowngardhead/:0:0","tags":null,"title":"个人整理的 iPhone 4S 降级至 iOS 6.1.3 的详细条件","uri":"/posts/2017-04-15-iphone4sdowngardhead/"},{"categories":["代码"],"content":"添加如下代码至网页的头部即可 ，conect接受颜色名和16进制颜色。 \u003cmeta name=\"theme-color\" content=\"YourColor\"\u003e 仅对移动版Chrome浏览器有效！ ","date":"2017-02-01","objectID":"/posts/2017-02-01-changechrometitlecolor/:0:0","tags":null,"title":"一行HTML更改Chrome移动版浏览器地址栏颜色","uri":"/posts/2017-02-01-changechrometitlecolor/"}]